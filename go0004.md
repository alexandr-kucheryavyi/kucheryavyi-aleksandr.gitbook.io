# Функції

Зауважте, що функції мають бути оголошені безпосередньо на рівні пакету. Іншими словами, функція не може бути оголошена в тілі іншої функції. Ми можемо визначати анонімні функції в тілах інших функцій. Але анонімні функції не є оголошеннями функцій.

* Функції в go можуть повертати декілька значень.
* вхідні параметри "a" і повертаемі значення "r" функції визначаються як звичайні змінні.
* повертаемі параметри можуть бути відсутні
* якщо повертаемий параметр тільки один то дужки мають бути відсутні

## Функції з однаковими іменами
В одному пакеті можуть існувати декілька функцій з однаковим імям.
* якщо це функція init
* якщо це функція з іменем _ але такі функції не можливо викликати

## Функція як тип
Можна створити змінну з типом функції, в таку змінну можна записати тільки таку функцію яка буде підходити по сигнатурі
```go
var f func() // default value is nil. 
```
Типи функція не можуть бути порівняні між собою але можуть бути порівняні з nil. 

## Виклики функцій
Виклики функції можуть йти в программі до її декларації. Не має значення коли створена функція.

## Вхідні параметри
* Усі параметри функції завжди передаються по значенню (копія)

Вхідні параметри можуть не мати імен. Компіляція пройде без проблем.
```go
func funcName (int) { // вхідний параметр без імені
}
```
Вхідні параметри та повертаємі параметри розглядаються як змінні які створються прямо в тілі функції. І якщо спробувати створити ще одну змінну з таким же іменем як і параметри то буде помилка компіляції.
```go
func funcName(a int) (b int) {
	var a int = 1 // a redeclared in this block
	var b int = 1 // b redeclared in this block
	return 0
}
```
Не певна кількість вхідних аргументів. Можна використати оператор упаковки/розпаковки для вхідних параметрів. Треба звернути увагу на те що в сигратурі функії ставиться оператор три крапки перед типом, а в момент виклику функції три крапки ставиться після агрументу. Важливо використовувати оператор три крапки як в сигнатурі функції так і під час виклику функції. 
```go
package main
import "fmt"
func myFunc(params ...int64) {
	for item := range params {
		fmt.Println(item++)
	}
}
func main() {
	p := []int64{1, 2, 3}
	myFunc(p...)
	fmt.Println(p)
}
```
Треба звернути увагу на те що в якості аргументу передаеться слайс і якщо змінити параметри в середині функції то ці зміни збережуться після завершення функції. ...T, можна розглядати як []T
```go
package main

import "fmt"

func myFunc(params ...int64) {
	params[0] = 777
}
func main() {
	p := []int64{1, 2, 3}
	myFunc(p...)
	fmt.Println(p)
	// [777 2 3]
}
```

Параметр з трьома крапками може бути тільки один в сигнатурі функції і обовязково має йти останнім.
```go
func myFunc(params1 ...int64, params2 ...int64) {
	fmt.Println(params1,params2)
}
//can only use ... with final parameter in list
```

Під час виклику функції зі змінним числом параметрів не можна одночасно використовувати передачу параметрів поштучно і розвертання слайсу.
```go
package main

import "fmt"

func Some(params ...int) {
	for key, val := range params {
		fmt.Println(key, val)
	}
}

func main() {
	// виклик з окремими змінними або літералами
	Some(1, 2, 3)

	// виклик зі слайсом який розвертаеться (увага на три крапки)
	sl := []int{4, 5, 6}
	Some(sl...)

	// комбінувати виклики не можна, буде помилка
	Some(1, 2, 3, sl...)
}

```


В go не має значень по замовчаню для вхідних параметрів. Параметри як і звичайні змінні можуть мати свої власні дефолтні значення і не більше того.
```go
func f() (x int, y bool) {
	println(x, y) // 0 false
	return
}
```

Як і звичайні змінні параметри функії можуть використовувати один тип на декілька параметрів. Це вірно як для вхідних параметрів так і для параметрів що повертаються.
```go
func f() (x , y int) {
}
```


## Повертаємі параметри
Повертаємі параметри можуть міститися в круглих дужках якщо їх декілька, треба звернути увагу на return який може не мати ніяких аргумеетів після себе, але ці параметри все одно повернуться з функції.

```go
func funcName () (r1 int, r2 bool) {
    return
}
```
Повертаемі параметри можуть бути без імен, тоді треба зауважити що return має повертати значення або змінні в тому порядку в якому вони ідуть в сигнатурі функції.
```go
func funcName() (int, bool) {
	return 1, false
}
```
Якщо повертаемий параметр один, то його можна писати в дужках а можна і без дужок. Але якщо параметрів два і більше то їх обовязково потрібно заключати в дужки.
```go
package main

func funcName1() (bool) {
	return false
}

func funcName2() bool {
	return false
}

func main() {
	r1 := funcName1()
    r2 := funcName2()
	println(r1,r2)
}

```
Повертаемі параметри можуть бути відсутні, але навіть тоді може бути присутнім слово return, але якщо спробувати використати значення яке ніби повертає функція то буде помилка компіляції
```go
package main

func funcName() {
	return
}

func main() {
	r := funcName()
	println(r)
}
// funcName() (no value) used as value
```
Імена вхідних параметрів функції та її повертаемих параметрів не можуть мати однакові імена, буде помилка компіляції
```go
package main

func funcName(a bool) (a bool) { // a redeclared in this block
	return false
}

func main() {
	r := funcName(true)
	println(r)
}
```

## Анонімні функції
Функція без імені. Можна відразу викликати.
```go
package main
func main() {
	func() {
	}()
}
```
Анонімну функцію можна записати в змінну.
```go
package main
func main() {
	f := func() {
	}
	f()
}
```
Можна створити змінну спеціального типу, яка буде приймати тільки анонімні функції спеціальної сигнатури.
```go
package main
var f func() // змінна типу фукнція без параметрів
func main() {
	f = func() { // записуемо функцію в змінну
	}
	f()
}
```
Вкладена анонімна функція може отримувати доступ до змінних батьківської функції на пряму, без отримування їх через параметри.
```go
package main

func main() {
	var a = 100

	func() {
		// надрукує змінну з батьківської функції
        println(a)
	}()
}
// 100
```

Так званий шадовінг або затінення локальними змінними тих змінних які мають точно таке імя в батьківській функції. Шадовінг може відбутися навіть через параметр анонімної функції, якщо у нього буде точно таке саме імя.
```go
package main

func main() {
	var a = 100

	func() {
		// локальна змінна затінить собою змінну з батьківської функції
        var a = 200 
		println(a)
	}()

	_ = a
}
// 200
```
Саме цікаве відбуваеться коли існує функція яка повертає іншу анонімну функцію і ця вкладена анонімна функція використовує змінні батьківської функції. Після того як батьківська функція припинить своє існування, усі її локальні змінні також припинять існування, окрім тих на які посилаеться вкладена функція. Можна подумати що змінна "а" буде знищена після того як відпрацює функція MakeFunc, тому що це локальна змінна цієї функції, але її використовує вкладена функція і тому ця змінна буде жити до тих пір поки на неї є посилання.
```go
package main

import "fmt"

func MakeFunc() func() int {
	// створюємо локальну змінну
    var a int 
	return func() int {
		// вкладена функція отримує доступ до батьківської змінної
        a++
		return a
	}
}

func main() {
	// викликаемо функцію яка поверне іншу функцію
    var f = MakeFunc()

	fmt.Println(f())
	fmt.Println(f())
	fmt.Println(f())
}
// 1
// 2
// 3
```

# Defer
Так само як і у горутин, усі повертаємі значення мають бути проігноровані. Горутина і функція для defer не мають повертати ніяких значень, в цьому не має ніякої потреби.

Може бути декілька defer в одній функції, вони всі викликаються в порядку протилежному до їх визначення. Тобто перший defer виконаеться останнім, останній який зустрічаеться в функції виконаеться першим.
```go
func SomeFunc() {
	defer func() { fmt.Println(1) }()
	defer func() { fmt.Println(2) }()
	defer func() { fmt.Println(3) }()
}
// 3
// 2
// 1
```
Сама по собі присутність defer ще не гарантує його виконання. Якщо припустімо не виконаеться якась умова то код defer не буде виконаний. В прикладі нижче спочатку виконаеться один defer а потім інший в залежності ві параметру який приймає функція.
```go
package main

import (
	"fmt"
)

func SomeFunc(cond bool) {
	if cond {
		defer func() { fmt.Println("defer TRUE has been running ...") }()
	} else {
		defer func() { fmt.Println("defer FALSE has been running ...") }()
	}

}

func main() {
	SomeFunc(true)
	SomeFunc(false)
}

```
Вкладені defer працюють точно так як і звичайні функції. Треба розглядати порядок виклику defer окремо по кожній функції. Якщо один defer вкладений в функцію то він буде розміщений в окрему чергу виклику саме для тої функції в яку він вкладений. Зовнішня функція по відношенню до вкладеної має свою окрему чергу викликів defer і вони ніяк не повязані між собою. Спочатку викличеться останній defer з функції SomeFunc, потім викличеться defer вкладений в нього, а потім ще один який вкладений в нього.
```go
package main

import (
	"fmt"
)

func SomeFunc() {
	defer func() {
		fmt.Println("10")
		defer func() {
			fmt.Println("  11")
			defer func() {
				fmt.Println("    12")
			}()
		}()
	}()

	defer func() {
		fmt.Println("20")
		defer func() {
			fmt.Println("  21")
			defer func() {
				fmt.Println("    22")
			}()
		}()
	}()

	defer func() {
		fmt.Println("30")
		defer func() {
			fmt.Println("  31")
			defer func() {
				fmt.Println("    32")
			}()
		}()
	}()

}

func main() {
	SomeFunc()
}
// 30
//   31
//     32
// 20
//   21
//     22
// 10
//   11
//     12
```
defer може модифікувати повертаєме значення яке повертає функція, але це значення має бути іменоване і описане в сігнатурі функції. В прикладі наведеному нижче видно що навіть якщо в функції явно вказано ***return n * n*** і у цьому виразі не фігурує змінна ***r*** але defer усе одно може її змінити.
```go
package main

import "fmt"

func Square(n int) (r int) {
	return n * n
}

func SquareDefer(n int) (r int) {
	defer func() {
		r *= 10 // значення що повертається буде модифіковано
	}()

	return n * n
}

func main() {
	fmt.Println(Square(2))
	fmt.Println(SquareDefer(2))
}

// 4
// 40
```
Параметри функції яка використовується в defer.

Параметри перебувають в тому стані в якому вони були на момент відправки функції в чергу.
```go
package main

import "fmt"

func main() {
	func() {
		for i := 0; i < 3; i++ {
			// на момент передачі в чергу параметри будуть мати різні значення
            // кожен параметр це копія змінної i
            // параметр ніяк не повязаний з цією змінною і
            defer fmt.Println("a:", i)
		}
	}()
	fmt.Println()
	func() {
		for i := 0; i < 3; i++ {
			defer func() {
				// на момент передачі в чергу параметри будуть мати одне і те ж значення, а саме посилання на i
                // після токо як цикл завершиться усі посилання на i будуть містити в собі значення 3
                fmt.Println("b:", i)
			}()
		}
	}()
}
// a: 2
// a: 1
// a: 0

// b: 3
// b: 3
// b: 3

```
Для того аби не мати посилання на змінну цикла, можна використати параметр для анонімної функції яка записана в defer
```go
for i := 0; i < 3; i++ {
    defer func(i int) {
        // i тепер копія значення змінної i з циклу
        fmt.Println("b:", i)
    }(i) // тут створюється копія
}
```
Для того аби не мати посилання на змінну циклу, можна зробити копію і зерегти значення в іншу змінну.
Використаємо замикання.
```go
for i := 0; i < 3; i++ {
    i := i // копія значення i з циклу в локальній змінній з таким самим імям
    defer func() {
        // локальна змінна яка містить копію значення i з циклу
        fmt.Println("b:", i)
    }()
}
```
## Передача в якості аргументу функції
* Функція може отримати массив лише заданої розмірності, не можливо задати агрумент як массив довільної розмірності. Лише [3]int
* Массив передаеться по значенню (копія), змінити массив всередині функції не можна.
* Слайс передаеться по значенню але має вказівник на массив отож змінити слайс всередині функції можна.
* Але якщо передати слайс то вказувати на новий массив він не зможе,append всередині функціі не дасть єфекту поза функцією.
* якщо передати мапу в функцію то в середині її можна змінити, але переопреділити аргумент щоб він вказував на іншу мапу не можна.

```golang
package main

import "fmt"

func FuncArr(a [3]int) {
	a[0] = 111
}
func FuncSlice(a []int) {
	a[0] = 111
}
func FuncSliceAppend(a []int) {
	a = append(a, 4)
}
func FuncMap(a map[int]int) {
	a[0] = 111
}

func FuncMapChange(a map[int]int) {
	a = map[int]int{0: 111}
}

func main() {
	// якщо всередині функції модифікувати массив то зовні це не проявиться
	var arr = [3]int{}
	FuncArr(arr)
	fmt.Println(arr)

	// якщо всередині функції модифікувати массив то зовні це проявиться
	var slc1 = []int{1, 2, 3}
	FuncSlice(slc1)
	fmt.Println(slc1)

	// якщо всередині функції append то зовні це не проявиться
	var slc2 = []int{1, 2, 3}
	FuncSliceAppend(slc2)
	fmt.Println(slc2)

	// якщо всередині функції модифікувати мапу то зовні це проявиться
	var map1 = map[int]int{0: 1, 1: 2, 2: 3}
	FuncMap(map1)
	fmt.Println(map1)

	// якщо в середині функції змінити записати в аргумент нову мапу то зовні це не проявиться
	var map2 = map[int]int{0: 1, 1: 2, 2: 3}
	FuncMapChange(map2)
	fmt.Println(map2)

}

```
