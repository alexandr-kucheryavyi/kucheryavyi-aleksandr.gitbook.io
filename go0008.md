# Pointers
Вказівник або поінтер це тип який може зберігати адресу пам'яті по якій можна знайти якесь значення.
В цьому прикладі типом виступає ****int*** ми просто створюємо змінну типу вказівник на тип int. 
```go
var PointerIntVar *int
```
В прикладі вище ми використали так званий не іменований вказівник. Тепер ми цей тип іменуємо.
```go
type PointerIntType *int
```
На основі цього типу ми можемо створювати нові змінні.І це не дуже хороша практика бо по типу не зрозуміло що цей тип вказівник.
```go
 type PointerIntType *int
 var PointerIntVar PointerIntType
```
Можна піти далі і створити вказівник на вказівник.
```go
*int // вказівник на int
**int // вказівник на *int

// те ж саме що і вище але більш заплутано
type Ptr *int
type PP *Ptr // на перший погляд не скажеш що це **int
```
Дефолтне значення вказівника nil. Якщо ми просто створимо змінну типу вказівник і спробуемо її роздрукувати то ми побачимо що цей вказівник нікуди не вказує, адреса відсутня, він зберігає nil
```go
var PointerIntVar *int
fmt.Println(PointerIntVar)
// <nil>
```
## Внутрішній вигляд деяких типів
Насправді map це вказівник і функція також. Хто б міг подумати.
```go
type _map *hashtableImpl
type _channel *channelImpl
type _function *functionImpl
```
## Порівняння вказівників
Вказівник можна порівняти з іншим вказівником за допомогою операторів == та != якщо дотримуються такі умови:
* типи обох поінтерів однакові
* тип одного поінтера може бути приведений до іншого, висхідні типи обох поінтерів все одно повинні бути однакові
* один з порівнюваних аргументів чистий nil

## NEW
New. Вбудована функція new приймає тип Т виділяє память для змінної цього типу під час виконання програми і повертає значення типу *Т яке вказує на цю ділянку памяті.

```go
var p *int
p = new(int)
```
## Локальний вказівник
Якщо повернути з функції вказівник то в інших мовах програмування окрім Go може статится помилка, але в Go є вбудований GC тому помилки не буде.
```go
func newInt() *int {
	a := 3
	return &a
}
```
## Оператор &
Оператор використовується для взяття адреси значення. Може застосовуватися для будь якого значення в якого можна взяти адресу, повертає *Т вказівник на тип.
```go
var i int
var p *int
p = &i // беремо адресу значення яке записане в змінну i
```
Можна взяти адреси з таких значень:
* змінні (variables)
* поля структури 
* елементи массиву 
* елементи слайсу 

Не можна взяти адреси з таких значень:
* байт в рядку тексту (bytes in strings)
* окремий елемент в map
* константа 
* літерал 

Треба звернути увагу на вираз. Це насправді не працювало б. Щоб це працювало під капотом проходить допоміжна операція.
```go
&T{}
```
Що відбуваеться насправді.
```go
tmp := T{}; 
(&tmp)
```

### Map

Чому не можна взяти адресу з елемента в середині map?

Перша причина це те що буде конфлікт з внутрішнім менеджером памяті в map. Так, так справа в тому що map має свій власний менеджер памяті. Map це контейнерний тип який може містити безлімітну кількість елементів якщо це дозволяє память.
Компілятор виділяє більше памяті ніж потрібно на випадок якщо будуть добавлятися нові елементи.
Може бути випадок коли елементи будуть переміщатися з одного місця в інше. Тобто адреса елемента в середині map змінюється час від часу.
Якщо б Go дозволяв робити вказівники на такі елементи то час від часу потрібно було б міняти адреси у всіх вказівниках, краще такого не робити.
Друга причина це те що під час спроби отримати елемента з map, такого може не бути і повернеться значення за замовченням.

### Slice

Чому усі елементи з не нулевого слайса завжди можуть дати адресу навіть якщо сам слайс не може дати адресу?

Насправді слайс це така структура:
```go
struct {
    // елементи посилання на елемент послідовності
	elements unsafe.Pointer
	length   int
	capacity int
}
```
В середині структури завжди є вказівник на послідовність данних. Навіть якщо сама структура (сам слайс) не адресуємий. Причина в тому що отримати адрес цього внутрішнього вказівника можна завжди.


## NEW vs оператор&
Чи є функція new(T) тотожною до операції & ?
```go
p := new(int)
```
В середині компілятора можливо що ці операції не тотожні і відрізняються, але по результату можна сказати що вони однакові.
```go
var i int
p := &i
```
Але можливо що ***new*** виділяє память тільки в heap? Книжка пише що вона може виділяти память як і в heap так і в stack. Як дізнатися де саме виділена память не зрозуміло.

## Pointer Dereference
При створенні типу використовується зірочка * поряд з типом, для якого створюеться вказівник. 
```go
var i *int
```
Але зірочка може використовуватися і для іншої операції. Записуемо значення в память по адресі яка записана в вказівнику.
```go
var i int
p := &i
*p = 1 // операція dereference, запишемо значення
```
Спочатку виймемо значення на яке вказує поінтер, візьмемо у цього значення адресу і запишимо цю адресу в інший вказівник. Як бачимо у всіх трьох вказівниках є одна і та сама адреса.
```go
p1 := new(int) // вказівник на нуль
p2 := p1       // інший вказівник на той самий нуль
p3 := &*p1     // *р1 беремо значення (а це 0) і беремо його адресу &0 і запишемо цю адресу в третій вказівник

println(p1) // 0xc000030768
println(p2) // 0xc000030768
println(p3) // 0xc000030768
```

## NEW vs MAKE

## NEW
Розміщує в памяті нові об'єкти, важливо пам'ятати що значення яке повертається це вказівник.
Вказівник на уже виділену пам'ять, на вже існуючий об'єкт.
```go
pS := new(aStructure)
```
Буде виділена пам'ять, створений об'єкт структури, всі поля структури будуть встановлені в нульові значення.
Але не можна сказати що ця структура була ініцілізована нульовими значеннями. (Чому не можна я не знаю).

Основна відмінність між NEW та MAKE полягає в тому що:
* змінні які створені new створються з обнуленою пам'ятю але не ініціалізовані, а змінні які створені за допомогою make правильно ініціалізовані а не просто мають обнулену пам'ять. 
* make не повертає вказівник
* new повертає вказівник

make може застосовуватися лише для:
* map
* chanel
* slice

Приклад коли можна оцінити різницю між new та make. Створюється вказівник на slice і створюється slice.
```go
pA := new([]int)
fmt.Println(*pA) // [] не має жодного елементу

mA := make([]int, 1)
fmt.Println(mA) // [0] елемент є і він ініціалізований дефолтним значенням
```


В этом примере команда new([]aStructure) выделяет в памяти место под поля описания
среза (срез в Go — это структура), но так как поля описания среза не инициированы, воз-
вращается указатель на nil. Чтобы в дальнейшем использовать переменную sP, нужно
инициализировать срез, выполнив команду make, например, *sP = make([]aStructure, 10).

## unsafe pointer 
В мові існують безпечні і не безпечні вказівники. Не безпечні вказівники використовують через пакет:
```go
unsafe
```
