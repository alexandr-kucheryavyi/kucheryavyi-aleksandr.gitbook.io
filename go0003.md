# Оператори і операції
Усі оператори використовують для своєї роботи операнди.

В залежності від кількості операндів, усі оператори розділяються на бінарні і унарні.

Бінарні оператори приймають два операнда, а унарні оператори приймають один операнд.

Операнди оператора можуть бути типізовані і не типізовані.

## Операнди
Якщо оператор вимагає щоб обидва його операнди були однакові, то це на справді означає:
* Якщо обидва операнди типізовані, то типи повинні бути однакові або один з них може НЕ ЯВНО приводитися до іншого
* Якщо тільки один з операндів типізований, то інший (не типізований) операнд має бути представлений як ЗНАЧЕННЯ типу першого операнда.
* Якщо обидва операнда не типізовані, то вони повинні бути обидва ЗНАЧЕННЯМ логічного, строкового, або обидва числового типу.

## Константні вирази
Якщо всі операнди у виразі є константами то такий вираз називаеться константним.

Усі константні вирази оцініються на єтапі компіляції.

Результат константного виразу також константа.

Якщо хоча б один операнд в виразі не є константою то увесь вираз не вважаеться константним.


## Приклади операцій
Спочатку здаеться що операція не можлива тому що операнди різних типів, але 'A' приводиться до типу int32
```go
a := 100 - 'A'
fmt.Println(fmt.Sprintf("%T", a), a)
// int32 35
```

```go
a := 100 * 'A'
fmt.Println(fmt.Sprintf("%T", a), a)
// int32 6500
```

Спочатку може здатися що операція можлива тому що два операнди типу int, але це не так, буде помилка компіляції тому що типи різні. 
```go
var a int8
var b int16
c := a + b
fmt.Println(fmt.Sprintf("%T", c), a)
// invalid operation: a + b (mismatched types int8 and int16)
```

## Переповнення
Переповнення не допускаеться при використанні типізованих констант. 

Якщо використовувати не типізовані константи то переповнення цілком можливо.

Переповнення можливе також з змінними.
```go
var a, b uint8 = 255, 1
// компіляція пройде без проблем
var c = a + b  // c == 0
```

## Інкремент і декремент ++, --
Важливо розуміти що ці оператори не повертають значення. Тому не можливо їх використовувати в виразах. Ці оператори повинн йти після змінної. 
Використовувати константу або літерал не можна.

```go
package main

func main() {
    const k = 111

	a, b, c := 12, 1.2, 1+2i
	a++ // ok. це не a += 1 це не a = a + 1
	b-- // ok. це не b -= 1 це не b = b - 1
	c++ // ok

	// помилка компіляції
	/*
		_ = a++
		_ = b--
		_ = c++
		++a
		--b
		++c
        5++
        v := 5++
        k++
	*/
}
```

## Приорітети операторів
Оператори мають пріоритет по рядках. Верхній рядок має пріорітет над нижнім. Оператори в одному рядку мають однаковий пріорітет і вираз враховує їх появу з ліва на право.
```go
*   /   %   <<  >>  &   &^
+   -   |   ^
==  !=  <   <=  >   >=
&&
||
```
Розглянемо простий код який наведено нижче.
Може здатися що відповідь буде 2.7 тому що спочатку спрацює оператор ділення "/" і права частина замість виразу 3/2 перетвориться на 1.5 насправді обидва операнди мають тип int тому результат буде 1 а не 1.5
тож в результаті 1.2 + 1 = 2.2
```go
var x = 1.2 + 3/2
```
Тут треба зауважити що оператор ділення і множення знаходяться на одному щаблі пріоритетів і тому вираз враховує їх позицію з ліва на право. Вони виконаються в порядку появи.

В прикладі наведнному нижче визначення константи x:
 * спочатку 3 "/" 2 сприймаеться як ділення цілочисленних значень int / int тому буде 1 а не 1.5
 * потім результат ділення множиться "*" на 0.1 
 * результат буде 0.1 а не 0.15

 В прикладі наведнному нижче визначення константи y:
 * спочатку 0.1 "*" 3 буде 0.3
 * потім результат ділиться "/" на 2 буде 0.15

```go
package main

const x = 3/2*0.1 // 3/2=1,     1*0.1=0.1
const y = 0.1*3/2 // 0.1*3=0.3, 0.3/2=1.5

func main() {
	println(x) // +1.000000e-001 = 0.1
	println(y) // +1.500000e-001 = 0.15
}
```