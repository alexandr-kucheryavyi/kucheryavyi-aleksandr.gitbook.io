# Константи

## Визначення нової константи без указанного типу
Тип визначаеться компілятором автоматично
```go
const π = 3.1416
```
Константу можна створити на основі іншої вже існуючої константи
```go
const Pi = π
```
При визначенні декількох констант використовується спеціальний синтаксис з дужками
```go
const (
// буде помилка не відома константа B, 
// тому що вона визначаеться нижче	
    A          = B 
    No         = !true
	Yes        = true
	MaxDegrees = 360
	Unit       = "radian"
    B          = "C"
)

```
При визначенні декількох констант використовується спеціальний синтаксис в один рядок
```go
const TwoPi, HalfPi, Unit2 = π * 2, π * 0.5, "degree"
```

## Визначення нової константи з вказаним типом данних 
```go
const Pi float64 = 3.1416
```
Константу можна створити на основі іншої вже існуючої константи
```go
const Pi2 float64 = Pi
```
При визначенні декількох констант використовується спеціальний синтаксис з дужками
```go
const (
	No         bool   = !true
	Yes        bool   = true
	MaxDegrees int    = 360
	Unit       string = "radian"
)
```
При визначенні декількох констант використовується спеціальний синтаксис в один рядок і тип може бути лише один, при відсутності типу значення можна підставляти які завгодно, але з типом лише потрібного типу
```go
// без типу значення можуть бути різних типів
const A,  B,  C        = 1, 2.2, "three"

// з типом значення можуть бути лише данного типу
const A1, B1, C1 int64 = 1, 2, 3
```
## Автопідстановка
Задаемо значення для перших двох констант, а інші константи будуть мати значення останьої, в нашому випадку це буде 2
```go
const (
	A = 1
	B = 2
	C
	D
)
// 	A=1, B=2, C=2, D=2
```

Пропускаемо одну константу, визначаемо тільки три константи
```go
const (
	A, B = "Go", "language"
	C, _
)
// A="Go", B="language", C="Go"
```

iota
```go
const (
	A="first"  // iota=0
    B="second" // iota=1
	C="third"  // iota=2
    D=iota     // iota=3
)
// A="first" B="second" C="third" D=3
```

Якщо не ставити тип даних при створенні константи то в константу можна записати значення яке не влізло б в тип данних якщо б він був би. Приведений код буде нормально скомпільований. Хоча в константи запишеться значення яке перевищує типи які вказанні в коментарях.

Це відбуваеться тому, що замість константи під час компіляції гошка підставляє літерал в усіх місцях де зустрічаеться константа.
```go
const n = 1 << 64          // overflows int
const r = 'a' + 0x7FFFFFFF // overflows rune
const x = 2e+308           // overflows float64

func main() {
	_ = n >> 2
	_ = r - 0x7FFFFFFF
	_ = x / 2
}
```
Якщо вказати типи данних то программа не відкомпілюеться.
```go
package main
import "fmt"

const n int = 1 << 64           // overflows int
const r rune = 'a' + 0x7FFFFFFF // overflows rune
const x float64 = 2e+308        // overflows float64

func main() {
	fmt.Println(n, r, x)
}
```

# Змінні
Створюємо нову змінну яка приймає значення за замовчуванням, для числових типів це 0
```go
var a int
```
Просто створити змінну без типу і без значення не можливо буде помилка
```go
var a
//unexpected newline, expecting type 
```
Можна створювати змінну і відразу її ініціалізувати значенням
```go
var a int = 1
```
Можна використати спеціальний синтаксис для створення декількох змінних одночасно. В такому випадку усі змінн повинні бути одного і того ж типу.
```go
var a,b,c int = 1,2,3
```

При створенні декількох змінних різних типів можна використати інший синтаксис
```go
var (
    a int = 1
    b float32 = 2.2
    c string = "str"
)
```
Змінні можна створювати в функціях і поза ними. Змінні можна створювати з вказанням типу і без вказання типу. Тип буде вираховуватися компілятором автоматично.
```go
var a = 1
```
```go
var a,b,c = 1,2,3
```
Без вказування типу можна ініціалізувати змінні різними типами
```go
var a,b,c = 1,2.2,"three"
```

```go
var (
    a = 1
    b = 2.2
    c = "str"
)
```
## Короткий запис
Створювати змінні можна без використання ключового слова var але з обовязковою ініціалізацією за допомогою спеціального оператора :=
```go
a := 1
```
Створення змінних коротким записом можливе лише в середині функцій, тобто локальних. ***Глобальні*** змінні таким чином створити не можна.

При створенні змінних коротким записом можна чередувати уже існуючі змінні і нові змінні але необхідно обовязково створити хоча б одну нову змінну інакше буде помилка компіляції
```go
var a = 1
var b = 2
a,b,c := 1,2,3
// код вище відпрацює нормально так як створюється нова змінна "с"
```

## Помилка створення по ланцюжку
Синтаксис створення в го не дозволяє ланцюжкового створення змінних
```go
var a, b int
a = b = 123 // syntax error
```

## Помилка не використана змінна
Змінні повинні бути використанні інакше буде помилка компіляції
```go
var a, b int
fmt.Println(a)
// b declared but not used
```

## Порядок створення змінних
Є залежність від того як саме створються змінні. Якщо створювати змінні локально, в середині функції і глобально, поза функціями то це може призвести до різних наслідків. При створенні глобальних змінних усі змінні проглядаються компілятором і порядок не має значення, а під час локального створення порядок грає роль.

Локальні змінні. На момент створення змінної "с" поки ще не існує
```go
package main
import "fmt"
func main() {
    var a = c
    var b = 2
    var c = 3
    fmt.Println(a,b,c)
}
// undefined: c
```
Але якщо винести створення змінних в глобальну область то помилки не буде.
```go
package main
import "fmt"
var a = c
var b = 2
var c = 3
func main() {
    fmt.Println(a,b,c)
}
// 3 2 3
```
Можна написати більш заплутаний приклад але нічого особливо не зміниться, глобальні змінні вираховуються і створюються не так як локальні. Тут помилки не буде.
```go
package main
import "fmt"
var x, y    = a+1, 5
var a, b, c = b+1, c+1, y
func main() {
    fmt.Println(x,y,a,b,c)
}
// 8 5 7 6 5
```
Якщо спробувати створити такі змінні локально то буде помилка
```go
package main
import "fmt"
func main() {
    var x, y    = a+1, 5
    var a, b, c = b+1, c+1, y
    fmt.Println(x,y,a,b,c)
}
// undefined: a
// undefined: b
// undefined: c
```
Якщо в глобальній області спробувати створити змінні які залежать від інших змінних циклічно, то буде помилка компіляції
```go
package main
import "fmt"
// циклічна залежність
var x, y = y, x
func main() {
	fmt.Println(x, y)
}
//nitialization loop for x
```
## Адресні і без адресні величини
Iснують адресні велечини і без адресні. Адресні величини мають адресу по яким їх можна знайти. 

Адресні:
* змінні

Без адресні:
* константи
* літерали

Усі ***змінні*** це адресні велечини усі ***константи*** це без адресні велечини. Літерали це також без адресні велечини.

Константа насправді це літерал який буде підставлений всюди де зустрічаеться константа.
