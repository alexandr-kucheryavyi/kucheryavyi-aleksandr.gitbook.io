# Типи данних

## Основні, вбудовані типи
* bool
* int8, uint8, int16, uint16, int32, uint32, int64, uint64, int, uint, and uintptr
* float32, float64
* complex64, complex128
* string

Усі типи данних які починаються з літери u називаються беззнакові. Вони не можуть містити значень меньше нуля.

Логічний тип данних може приймати лише два значення. Нижній регістр літер має значення.
* true
* false

## Основні, вбудовані псевдоніми
* byte є псевдонімом для uint8
* rune є псевдонімом для int32

## Користувацькі типи
Новий тип можна створити на основі вже існуючого. Нижче наведений приклад створення нових типів на основі вбудованих існуючих типів.
```go
// status і bool це два різних типи
type status bool

// MyString і string два різних типи
type MyString string

// Id і uint64 два різних типи
type Id uint64

// real і float32 два різних типи
type real float32
```

## Користувацькі псевдоніми
Треба бути уважним і розрізняти ***створення типів*** на основі вже існуючих і ***створення псевдонімів*** для вже існуючих типів. Потрібно звертати увагу на знак =

Створення користувацьких псевдонімів:
```go
// boolean і bool це один і той самий тип
type boolean = bool

// Text and string це один і той самий тип
type Text = string

// U8, uint8 and byte це один і той самий тип
type U8 = uint8

// char, rune and int32 це один і той самий тип
type char = rune
```

## Нульові значення (zero value)
Кожен тип має своє нульове значення або значення за замовчуванням.
* zero value для бульового типу це flase
* zero value для числових типів це 0
* zero value для строкового типу це "" пустий рядок

## Літерали
### Для логічних значень:
* true / false в нижньому регістрі технічно не є літералами, бо це насправді вбудовані константи

### Для цілочисленних значень:
Для розділення великих літералів можна застосовувати _ нижне підкреслення 10_000_000 але літерал не повинен починатися з
цього символу і завершуватися ним. Також не можна ставити 2 таких символи підряд. 

```go
// 16 значна система починається з "0x","0X"
0xF
0XF

// 8 значна система починаеться з "0","0o","0O"
017
0o17
0O17

// 2 значна система починаеться з "0b","0B"
0b1111 
0B1111

// 10 значна система НЕ починаеться з "0"
15
```
### Типи літералів 
Якщо створювати коснтанту або змінну без вказання типу, тільки за допомогою літералів то такі змінні будуть мати тип по замовчуванню.
```go
// Для дійсних типів це float64 
const A = 3.15 

// Для цілочисленних це int
const A = 3 
```

## Приведення типів данних
Аби привести один тип до другого треба використати такий синтаксис:
```go
T(v)
```

* T - назва типу до якого приводимо
* v - значення яке буде приводитися

Якщо тип можна привести, то така дія буде
виконана, але в деяких випадках це буде не можливо. 

Тут потрібно звернути увагу що приведення змінних і констант і літералів трохи відрізняеться. То що можна зробити зі змінною то для констант або літералів не дозволяеться

Константа насправді це літерал який буде підставлений всюди де зустрічаеться константа.

Не константне число з плаваючою комою і ціле число можна привести одне до одного.

Якщо створити змінну типу float64 і привести її значення до типу int то все буде гаразд, помилки небуде. При приведенні дробна частина відкидаеться.
```go
package main
import "fmt"

func main() {
    // Створюємо змінну типу float64 і приводимо його її значення до типу int
    var a float64 = 10.1
	var i int  = int(a)
	fmt.Println(i)
    // буде надруковано 10
}
```
Якщо замість змінної спробувати привести літерал, то буде помилка тому що є дробна частина, але якщо спробувати привести літерал дробна частина якого буде нуль, то помилки не буде. Цей приклад наведено нижче.
```go
package main
import "fmt"

func main() {
    // Намагаємося привести до типу int літерал  float64
	var i int  = int(10.1)
	fmt.Println(i)
    // буде помилка 
    // cannot convert 10.1 (untyped float constant) to type int
}
```
Якщо спробувати привести не літерал і не змінну а константу то також буде помилка. Тому що є дробна частина більше за нуль. Якщо дробна частина буде нуль то помилки небуде. Приклад наведено нижче.
```go
package main
import "fmt"

func main() {
    // Створюємо константу типу float64 і приводимо його її значення до типу int
	const a float64 = 10.1
	var i int = int(a)
	fmt.Println(i)
    // cannot convert a (constant 10.1 of type float64) to type int
}
```
А тепер спробуемо привести число яке раніше не можливо було привести, але трохи змінемо його, замінимо дробну частину на нуль. Помилки не буде і усе приведеться нормально.
```go
package main
import "fmt"

func main() {
	// константа з плаваючою крапкою але дробна частина нуль
    const a float64 = 10.0 
	var i int = int(a)
	// літерал з плаваючою крапкою але дробна частина нуль
    var j int = int(10.0) 
	fmt.Println(i, j)
    // 10 10
}
```

Створюємо змінну типу int і записуемо туди значення меньше нуля, потім приводимо його до типу uint і отримуемо значення яке не очікували, хоча помилки не буде
```go
package main
import "fmt"

func main() {
    var a int  = -1
    var i uint  = uint(a)
	fmt.Println(i)
    // 18446744073709551615
}
```
Спроба привести літерал зі значенням числа меньше нуля в тип uint
```go
package main
import "fmt"

func main() {
    var i uint  = uint(-10)
	fmt.Println(i)
    // буде помилка 
    //cannot convert -10 (untyped int constant) to type uint
}
```

Створюємо змінну типу bool і пробуемо привести її до типу uint
```go
package main
import "fmt"

func main() {
    var a bool  = false
    var i uint  = uint(a)
	fmt.Println(i)
    // cannot convert a (variable of type bool) to type uint
}
```

Пробуемо привести літерал логічного значення до типу 
```go
package main
import "fmt"

func main() {
    var i int  = int(false)
	fmt.Println(i)
    // cannot convert false (untyped bool constant) to type int
}
```
При спробі привести такий літерал до типу float32 ніякого округлення не буде
```go
package main
import "fmt"

func main() {
    var i float32 = float32(0.49)
	fmt.Println(i)
    // 0.49
}

```
При спробі привести такий літерал до типу float32  буде округлення
```go
package main
import "fmt"

func main() {
    var i float32 = float32(0.49999999)
	fmt.Println(i)
    // 0.5
}
```
## Автоматичне визначення типу (Deductions) 

Така процедура викликаеться компілятором у випадку: 
* Декларування констант const π = 3.141
