# Map
Ми можемо отримати доступ до єлементів через ключ.
Чаз затрачений на доступ до єлементів контейнерних типів изначаеться за функцією O(1). Доступ до єлементів в map в декілька разів повільніше ніж в массивах і слайсах але map має дві переваги перед масивами і слайсами:
* тип ключа може бути будь якого типу який підтримує операція == та !=
* map витрачає на багато меньше памяті чим массиви чи слайси якщо більшість з єлементів нулі.

Мапа це не впорядкована хеш таблиця.
* у мапи немає cap (cap у мапи безкінечність, немає сенсу в її використанні.) але є len
* на відміну від слайса, при ініціалізації мапи, ключі обов'язкові.
* якщо створити змінну без ініціалізації то користуватися нею не можливо, потрібен або {} або make()
* на відміну від слайсу, якщо ініціалізувати лише чреез {} то змінною уже можна користуватися.

Коли створюється змінна типу масива без ініціалізації память під цей массив також виділяється і всі елементи набувають значення по замовчуванню, для слайсів і мапів це не відноситься. Для слайсів і мапів память не алокуеться і елементи не набувають дефолтних значень.

* якщо йде спроба доступа до мапи по ключу а сама мапа nil то тоді буде отримано значення по замовченню
* якщо йде спроба доступа до мапи по ключу а сама мапа НЕ nil і такого ключа не має то тоді буде отримано значення по замовченню
* якщо йде спроба запису в мапу по ключу а сама мапа nil то тоді буде паніка
* якщо йде спроба запису в мапу по ключу а сама мапа НЕ nil то тоді буде створений ключ і значення

декларування мапи
```golang
	// створення змінної, буде створенна мапа len = 0, map[]
	var a1 map[int]int
	// a1[0] = 0 // буде помилка assignment to entry in nil map
	fmt.Println("1)", a1, "len", len(a1), fmt.Sprintf("%T", a1))

	// створення змінної, буде створенна мапа len = 0, map[]
	var a2 = map[int]int{}
	a2[0] = 0 // помилки не буде
	a2[5] = 0 // помилки не буде
	fmt.Println("2)", a2, "len", len(a2), fmt.Sprintf("%T", a2))

	// створення змінної і відразу ініціалізація, без вказання ключів
	// var a3 = map[int]int{1, 2, 3} // буде помилка  missing key in map literal

	// створення змінної через make, буде створенна мапа len = 0, map[]
	var a4 = make(map[int]int)
	a4[0] = 0 // помилки не буде
	a4[5] = 0 // помилки не буде
	fmt.Println("4)", a4, "len", len(a4), fmt.Sprintf("%T", a4))

	// створення змінної без вказання типу, :=

	// помилка map[int]int (type) is not an expression
	// a5 := map[int]int

	// створення змінної і відразу ініціалізація, буде створенна мапа [0,0,0]
	a6 := map[int]int{}
	// a6[0] = 0 // буде помилка
	fmt.Println("5)", a6, "len", len(a6))

	// створення змінної і відразу ініціалізація, буде створенний слайс len = 3,  map[0:0 1:2 20:3]
	a7 := map[int]byte{0: 1, 1: 2, 20: 3}
	a7[0] = 0
	fmt.Println("6)", a7, "len", len(a7))
```
## Порівняння з nil
Map можна порівнювати з nil на відміну від массива. Якщо порівнювати не ініціалізований map з nil то буде true а якщо ініціалізований, навіть якщо не прописати жодного елементу то порівняння з nill буде false.
```go
var c map[int]int
fmt.Println(c == nil) // true
var c1 = map[int]int{}
fmt.Println(c1 == nil) // false
```

## Запис в змінні
Змінні будуть посилатися на одну і ту ж мапу і змінювати її також будуть. Так що треба бути обережним і пам'ятати що обидві змінні будуть вкзувати на одну і ту ж мапу.
```go
m1 := map[int]int{0: 0, 1: 1, 2: 2}
m2 := m1

m1[0] = 777

fmt.Println(m1)
fmt.Println(m2)
// map[0:777 1:1 2:2]
// map[0:777 1:1 2:2]
```
## delete
Видаляємо елемент з мапи
```go
m := map[int]int{0: 0, 1: 1, 2: 2}
delete(m, 0)
fmt.Println(m)
// map[1:1 2:2]
```
## make для map
Навіть якщо явно вказати розмір при створенні через make то все одно це не буде мати сенсу.
```go
m1 := make(map[string]int) // можна не вказувати розмір, помилки не буде, це не слайс
m2 := make(map[string]int, 300)
fmt.Println(m1) // map[]
fmt.Println(m2) // map[]
```
## new для map
Для створення мапи new не використовується
```go
m := *new(map[string]int)
// буде помилка panic: assignment to entry in nil map
// m["ZERO"] = 0
fmt.Println(m == nil) // true
fmt.Println(m)        // map[]
```
## Вказівник на елемент
Елементи в мапі не можуть бути адресованими. На них не можливо зробити вказівник.
```go
m := map[int]int{0: 0, 1: 1, 2: 2}
fmt.Println(&m[0])
// invalid operation: cannot take address of m[0] (map index expression of type int)
```
Якщо в елемент мапи записати массив або структуру то такий елемент можна буде замінити повністю на новий, але змінити його не можна буде.
```go
fmt.Println(m3["THREE"][0])        // доступ на читання ок
            m3["THREE"][0] = 777   // доступ на запис помилка

fmt.Println(m2["TWO"].fieldA)      // доступ на читання ок
            m2["TWO"].fieldA = 777 // доступ на запис помилка
```
```go
package main

import "fmt"

func main() {
	m := map[string]int64{}
	m["ONE"] = 1
	fmt.Println(m["ONE"])

	type MyTypeStruct struct {
		fieldA int64
	}
	m2 := map[string]MyTypeStruct{}
	m2["TWO"] = MyTypeStruct{fieldA: 1}

	// прочитати елемент можна, а записати не можна :)
	fmt.Println(m2["TWO"].fieldA)
	//m2["TWO"].fieldA = 2
	// cannot assign to struct field m2["TWO"].fieldA in map

	// замінити елемент на новий можна
	ns := MyTypeStruct{fieldA: 777}
	m2["TWO"] = ns

	fmt.Println(m2)

	var m3 map[string][3]int64 = make(map[string][3]int64)
	m3["THREE"] = [3]int64{0, 1, 2}

	// прочитати елемент можна, а записати не можна :)
	fmt.Println(m3["THREE"][0])
	// m3["THREE"][0] = 777
	// cannot assign to m3["THREE"][0] (value of type int64)

	// замінити елемент на новий можна
	na := [3]int64{777, 888, 999}
	m3["THREE"] = na

	fmt.Println(m3["THREE"])
}
```