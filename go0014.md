# Array
В масиві йогорозмірніть є частиною типу. Створюються дві змінних абсолютно різних типів. Якщо параметр функції буде массив, то функція зможе прийняти лише чітко описаний массив і ніякий інший. Жоден з масивів не підійде окрім описаного, це не підійде:  [5]int64 [6]int64 [8]int64 і так далі
```go
// різні і не тотожні типи
var arr1 [5]int64 
var arr2 [6]int64

// параметр може бути лише [7]int64 і ніякий інший
func SomeFunc(param [7]int64){
}
```
Коли створюється змінна типу масива без ініціалізації память під цей массив також виділяється і всі елементи набувають значення по замовчуванню, для слайсів і мапів це не відноситься. Для слайсів і мапів память не алокуеться і елементи не набувають дефолтних значень.


* Намагання доступу за межами массиву викличе паніку.
* Розмірність массиву не може задаватися динамічно.
* Розмірність можна задати через константу але не через змінну.
* створити константу массив не можна
* cap та len в масиві ніколи не змінються 
* якщо ключ по якому йде спроба отримати значення більший ніж містить массив то буде паніка


## Декларування масива.
Може здатися що створиться лише змінна типу масив але створиться і сам масив, елементи якого отримають значення по замовчанню. Довжина len = 3 усі елементи матимуть дефолтні значення.
```go
var arr [3]int
// [0 0 0]
```
Cтворення змінної і відразу ініціалізація. Треба зауважити що тип змінної не вказуеться. 
```go
// буде створенний массив len = 3,  [1,2,3]
var arr = [3]int{1, 2, 3}
```
Cтворення змінної і відразу ініціалізація. Треба зауважити що тип змінної вказуеться. 
```go
// буде створенний массив len = 3,  [1,2,3]
var arr [3]int = [3]int{1, 2, 3}
```
Створення змінної і відразу ініціалізація, буде створенний массив len = 3 компілятор підставить значееня розміру самостійно.
```go
var arr  = [...]int{1, 2, 3}
```
Спробуємо створити масив з типом в якому присутні три крапки і отримаємо помилку.
```go
// буде помилка компіляції
var arr [...]int = [...]int{1, 2, 3}
```
Створення коротким записом.
```go
arr := [3]int{}
//[0 0 0]
```
Створення коротким записом і відразу ініціалізація.
```go
arr := [3]byte{1, 2, 3}
```
а тут створиться массив розміром 0 і користуватися таким масивом буде не можливо
```go
arr := [...]int{}
arr[0] = 1 // буде помилка
```

Створення коротким записом і відразу ініціалізація і компілятор сам поставить розмір масиву.
```go
arr := [...]int{1, 2, 3}
arr[0] = 1 // помилки не буде
```

## Порівняння з nil
```go
var a [3]int
fmt.Println(a == nil) // помилка mismatched types [3]int and untyped nil
```
## Запис в змінні
Змінні будуть посилатися на один і той й же слайс і змінювати її також будуть. Так що треба бути обережним і пам'ятати що обидві змінні будуть вкзувати на один і то й же слайс.
```go
s1 := [...]int{0, 1, 2}
s2 := s1
s1[0] = 777
fmt.Println(s1)
fmt.Println(s2)
// [777 1 2]
// [0 1 2]
```

## make для масивів
Не можна використовувати.

## new для массивів
Для створення массивів не використовують new хоча він створить нормальну змінну і можна користуватися але це не має змісту.
```go
a := *new([3]bool)
a[0] = true
fmt.Println(a == [3]bool{}) // false
fmt.Println(a)              // [true false false]
```

## Вказівник на елемент
Елементи в массиві можуть бути адресованими.
```go
a := [3]int{0: 0, 1: 1, 2: 2}
fmt.Println(&a[0], *&a[0], a[0])
// 0xc0000ba000 0 0
```
Розмір массиву та капасіті массиву можна використати як константу.
```go
package main

import "fmt"

var a [5]int
var p *[7]string

// N  M обидві константи, я думав що буде помилка
const N = len(a)
const M = cap(p)

func main() {
	fmt.Println(N) // 5
	fmt.Println(M) // 7
}
```


Modify the Length and Capacity 